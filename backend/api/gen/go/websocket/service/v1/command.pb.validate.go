// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: websocket/service/v1/command.proto

package servicev1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Command with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Command) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Command with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in CommandMultiError, or nil if none found.
func (m *Command) ValidateAll() error {
	return m.validate(true)
}

func (m *Command) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Seq

	// no validation rules for RequestId

	for idx, item := range m.GetEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  fmt.Sprintf("Events[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  fmt.Sprintf("Events[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetTimestamp()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CommandValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CommandValidationError{
					field:  "Timestamp",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTimestamp()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CommandValidationError{
				field:  "Timestamp",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Payload.(type) {
	case *Command_Init:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetInit()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "Init",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "Init",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInit()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "Init",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_Echo:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEcho()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "Echo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "Echo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEcho()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "Echo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_Notify:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNotify()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "Notify",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "Notify",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNotify()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "Notify",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_Resync:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetResync()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "Resync",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "Resync",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResync()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "Resync",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_ActorRegister:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetActorRegister()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ActorRegister",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ActorRegister",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActorRegister()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "ActorRegister",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_ActorUnregister:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetActorUnregister()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ActorUnregister",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ActorUnregister",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActorUnregister()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "ActorUnregister",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_ActorHeartbeat:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetActorHeartbeat()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ActorHeartbeat",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ActorHeartbeat",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActorHeartbeat()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "ActorHeartbeat",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_ActorStatus:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetActorStatus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ActorStatus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ActorStatus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActorStatus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "ActorStatus",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_ActorList:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetActorList()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ActorList",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ActorList",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetActorList()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "ActorList",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_RobotStart:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRobotStart()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotStart",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotStart",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRobotStart()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "RobotStart",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_RobotStop:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRobotStop()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotStop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotStop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRobotStop()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "RobotStop",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_RobotConfig:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRobotConfig()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotConfig",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRobotConfig()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "RobotConfig",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_RobotCommand:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRobotCommand()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotCommand",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotCommand",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRobotCommand()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "RobotCommand",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_RobotResult:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRobotResult()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotResult",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotResult",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRobotResult()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "RobotResult",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_ServerSync:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServerSync()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ServerSync",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ServerSync",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServerSync()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "ServerSync",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_ServerStatus:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetServerStatus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ServerStatus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "ServerStatus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetServerStatus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "ServerStatus",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_AlertSend:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAlertSend()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "AlertSend",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "AlertSend",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAlertSend()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "AlertSend",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_AlertAck:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAlertAck()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "AlertAck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "AlertAck",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAlertAck()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "AlertAck",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_UserKick:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUserKick()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "UserKick",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "UserKick",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUserKick()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "UserKick",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_UserBroadcast:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUserBroadcast()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "UserBroadcast",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "UserBroadcast",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUserBroadcast()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "UserBroadcast",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Command_RobotSync:
		if v == nil {
			err := CommandValidationError{
				field:  "Payload",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRobotSync()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotSync",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "RobotSync",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRobotSync()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "RobotSync",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.Error != nil {

		if all {
			switch v := interface{}(m.GetError()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CommandValidationError{
						field:  "Error",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetError()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CommandValidationError{
					field:  "Error",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CommandMultiError(errors)
	}

	return nil
}

// CommandMultiError is an error wrapping multiple validation errors returned
// by Command.ValidateAll() if the designated constraints aren't met.
type CommandMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CommandMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CommandMultiError) AllErrors() []error { return m }

// CommandValidationError is the validation error returned by Command.Validate
// if the designated constraints aren't met.
type CommandValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CommandValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CommandValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CommandValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CommandValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CommandValidationError) ErrorName() string { return "CommandValidationError" }

// Error satisfies the builtin error interface
func (e CommandValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCommand.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CommandValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CommandValidationError{}

// Validate checks the field values on InitCmd with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *InitCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitCmd with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InitCmdMultiError, or nil if none found.
func (m *InitCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *InitCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InitCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InitCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InitCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InitCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InitCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InitCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InitCmdMultiError(errors)
	}

	return nil
}

// InitCmdMultiError is an error wrapping multiple validation errors returned
// by InitCmd.ValidateAll() if the designated constraints aren't met.
type InitCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitCmdMultiError) AllErrors() []error { return m }

// InitCmdValidationError is the validation error returned by InitCmd.Validate
// if the designated constraints aren't met.
type InitCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitCmdValidationError) ErrorName() string { return "InitCmdValidationError" }

// Error satisfies the builtin error interface
func (e InitCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitCmdValidationError{}

// Validate checks the field values on EchoCmd with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EchoCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EchoCmd with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EchoCmdMultiError, or nil if none found.
func (m *EchoCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *EchoCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EchoCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EchoCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EchoCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EchoCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EchoCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EchoCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EchoCmdMultiError(errors)
	}

	return nil
}

// EchoCmdMultiError is an error wrapping multiple validation errors returned
// by EchoCmd.ValidateAll() if the designated constraints aren't met.
type EchoCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EchoCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EchoCmdMultiError) AllErrors() []error { return m }

// EchoCmdValidationError is the validation error returned by EchoCmd.Validate
// if the designated constraints aren't met.
type EchoCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EchoCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EchoCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EchoCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EchoCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EchoCmdValidationError) ErrorName() string { return "EchoCmdValidationError" }

// Error satisfies the builtin error interface
func (e EchoCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEchoCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EchoCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EchoCmdValidationError{}

// Validate checks the field values on NotifyCmd with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NotifyCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NotifyCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NotifyCmdMultiError, or nil
// if none found.
func (m *NotifyCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *NotifyCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NotifyCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NotifyCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NotifyCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return NotifyCmdMultiError(errors)
	}

	return nil
}

// NotifyCmdMultiError is an error wrapping multiple validation errors returned
// by NotifyCmd.ValidateAll() if the designated constraints aren't met.
type NotifyCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NotifyCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NotifyCmdMultiError) AllErrors() []error { return m }

// NotifyCmdValidationError is the validation error returned by
// NotifyCmd.Validate if the designated constraints aren't met.
type NotifyCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NotifyCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NotifyCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NotifyCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NotifyCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NotifyCmdValidationError) ErrorName() string { return "NotifyCmdValidationError" }

// Error satisfies the builtin error interface
func (e NotifyCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNotifyCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NotifyCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NotifyCmdValidationError{}

// Validate checks the field values on ResyncCmd with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResyncCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResyncCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResyncCmdMultiError, or nil
// if none found.
func (m *ResyncCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *ResyncCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ResyncCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ResyncCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ResyncCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ResyncCmdMultiError(errors)
	}

	return nil
}

// ResyncCmdMultiError is an error wrapping multiple validation errors returned
// by ResyncCmd.ValidateAll() if the designated constraints aren't met.
type ResyncCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResyncCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResyncCmdMultiError) AllErrors() []error { return m }

// ResyncCmdValidationError is the validation error returned by
// ResyncCmd.Validate if the designated constraints aren't met.
type ResyncCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResyncCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResyncCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResyncCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResyncCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResyncCmdValidationError) ErrorName() string { return "ResyncCmdValidationError" }

// Error satisfies the builtin error interface
func (e ResyncCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResyncCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResyncCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResyncCmdValidationError{}

// Validate checks the field values on ActorRegisterCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ActorRegisterCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActorRegisterCmd with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActorRegisterCmdMultiError, or nil if none found.
func (m *ActorRegisterCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *ActorRegisterCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActorRegisterCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActorRegisterCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActorRegisterCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActorRegisterCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActorRegisterCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActorRegisterCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActorRegisterCmdMultiError(errors)
	}

	return nil
}

// ActorRegisterCmdMultiError is an error wrapping multiple validation errors
// returned by ActorRegisterCmd.ValidateAll() if the designated constraints
// aren't met.
type ActorRegisterCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActorRegisterCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActorRegisterCmdMultiError) AllErrors() []error { return m }

// ActorRegisterCmdValidationError is the validation error returned by
// ActorRegisterCmd.Validate if the designated constraints aren't met.
type ActorRegisterCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActorRegisterCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActorRegisterCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActorRegisterCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActorRegisterCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActorRegisterCmdValidationError) ErrorName() string { return "ActorRegisterCmdValidationError" }

// Error satisfies the builtin error interface
func (e ActorRegisterCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActorRegisterCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActorRegisterCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActorRegisterCmdValidationError{}

// Validate checks the field values on ActorUnregisterCmd with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ActorUnregisterCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActorUnregisterCmd with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActorUnregisterCmdMultiError, or nil if none found.
func (m *ActorUnregisterCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *ActorUnregisterCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActorUnregisterCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActorUnregisterCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActorUnregisterCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActorUnregisterCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActorUnregisterCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActorUnregisterCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActorUnregisterCmdMultiError(errors)
	}

	return nil
}

// ActorUnregisterCmdMultiError is an error wrapping multiple validation errors
// returned by ActorUnregisterCmd.ValidateAll() if the designated constraints
// aren't met.
type ActorUnregisterCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActorUnregisterCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActorUnregisterCmdMultiError) AllErrors() []error { return m }

// ActorUnregisterCmdValidationError is the validation error returned by
// ActorUnregisterCmd.Validate if the designated constraints aren't met.
type ActorUnregisterCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActorUnregisterCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActorUnregisterCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActorUnregisterCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActorUnregisterCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActorUnregisterCmdValidationError) ErrorName() string {
	return "ActorUnregisterCmdValidationError"
}

// Error satisfies the builtin error interface
func (e ActorUnregisterCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActorUnregisterCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActorUnregisterCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActorUnregisterCmdValidationError{}

// Validate checks the field values on ActorHeartbeatCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ActorHeartbeatCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActorHeartbeatCmd with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ActorHeartbeatCmdMultiError, or nil if none found.
func (m *ActorHeartbeatCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *ActorHeartbeatCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActorHeartbeatCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActorHeartbeatCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActorHeartbeatCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActorHeartbeatCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActorHeartbeatCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActorHeartbeatCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActorHeartbeatCmdMultiError(errors)
	}

	return nil
}

// ActorHeartbeatCmdMultiError is an error wrapping multiple validation errors
// returned by ActorHeartbeatCmd.ValidateAll() if the designated constraints
// aren't met.
type ActorHeartbeatCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActorHeartbeatCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActorHeartbeatCmdMultiError) AllErrors() []error { return m }

// ActorHeartbeatCmdValidationError is the validation error returned by
// ActorHeartbeatCmd.Validate if the designated constraints aren't met.
type ActorHeartbeatCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActorHeartbeatCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActorHeartbeatCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActorHeartbeatCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActorHeartbeatCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActorHeartbeatCmdValidationError) ErrorName() string {
	return "ActorHeartbeatCmdValidationError"
}

// Error satisfies the builtin error interface
func (e ActorHeartbeatCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActorHeartbeatCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActorHeartbeatCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActorHeartbeatCmdValidationError{}

// Validate checks the field values on ActorStatusCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActorStatusCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActorStatusCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActorStatusCmdMultiError,
// or nil if none found.
func (m *ActorStatusCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *ActorStatusCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActorStatusCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActorStatusCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActorStatusCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActorStatusCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActorStatusCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActorStatusCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActorStatusCmdMultiError(errors)
	}

	return nil
}

// ActorStatusCmdMultiError is an error wrapping multiple validation errors
// returned by ActorStatusCmd.ValidateAll() if the designated constraints
// aren't met.
type ActorStatusCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActorStatusCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActorStatusCmdMultiError) AllErrors() []error { return m }

// ActorStatusCmdValidationError is the validation error returned by
// ActorStatusCmd.Validate if the designated constraints aren't met.
type ActorStatusCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActorStatusCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActorStatusCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActorStatusCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActorStatusCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActorStatusCmdValidationError) ErrorName() string { return "ActorStatusCmdValidationError" }

// Error satisfies the builtin error interface
func (e ActorStatusCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActorStatusCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActorStatusCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActorStatusCmdValidationError{}

// Validate checks the field values on ActorListCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActorListCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActorListCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActorListCmdMultiError, or
// nil if none found.
func (m *ActorListCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *ActorListCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActorListCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActorListCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActorListCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActorListCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActorListCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActorListCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActorListCmdMultiError(errors)
	}

	return nil
}

// ActorListCmdMultiError is an error wrapping multiple validation errors
// returned by ActorListCmd.ValidateAll() if the designated constraints aren't met.
type ActorListCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActorListCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActorListCmdMultiError) AllErrors() []error { return m }

// ActorListCmdValidationError is the validation error returned by
// ActorListCmd.Validate if the designated constraints aren't met.
type ActorListCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActorListCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActorListCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActorListCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActorListCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActorListCmdValidationError) ErrorName() string { return "ActorListCmdValidationError" }

// Error satisfies the builtin error interface
func (e ActorListCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActorListCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActorListCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActorListCmdValidationError{}

// Validate checks the field values on RobotStartCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RobotStartCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RobotStartCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RobotStartCmdMultiError, or
// nil if none found.
func (m *RobotStartCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *RobotStartCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotStartCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotStartCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotStartCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotStartCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotStartCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotStartCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RobotStartCmdMultiError(errors)
	}

	return nil
}

// RobotStartCmdMultiError is an error wrapping multiple validation errors
// returned by RobotStartCmd.ValidateAll() if the designated constraints
// aren't met.
type RobotStartCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RobotStartCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RobotStartCmdMultiError) AllErrors() []error { return m }

// RobotStartCmdValidationError is the validation error returned by
// RobotStartCmd.Validate if the designated constraints aren't met.
type RobotStartCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RobotStartCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RobotStartCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RobotStartCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RobotStartCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RobotStartCmdValidationError) ErrorName() string { return "RobotStartCmdValidationError" }

// Error satisfies the builtin error interface
func (e RobotStartCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRobotStartCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RobotStartCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RobotStartCmdValidationError{}

// Validate checks the field values on RobotStopCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RobotStopCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RobotStopCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RobotStopCmdMultiError, or
// nil if none found.
func (m *RobotStopCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *RobotStopCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotStopCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotStopCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotStopCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotStopCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotStopCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotStopCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RobotStopCmdMultiError(errors)
	}

	return nil
}

// RobotStopCmdMultiError is an error wrapping multiple validation errors
// returned by RobotStopCmd.ValidateAll() if the designated constraints aren't met.
type RobotStopCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RobotStopCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RobotStopCmdMultiError) AllErrors() []error { return m }

// RobotStopCmdValidationError is the validation error returned by
// RobotStopCmd.Validate if the designated constraints aren't met.
type RobotStopCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RobotStopCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RobotStopCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RobotStopCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RobotStopCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RobotStopCmdValidationError) ErrorName() string { return "RobotStopCmdValidationError" }

// Error satisfies the builtin error interface
func (e RobotStopCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRobotStopCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RobotStopCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RobotStopCmdValidationError{}

// Validate checks the field values on RobotConfigCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RobotConfigCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RobotConfigCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RobotConfigCmdMultiError,
// or nil if none found.
func (m *RobotConfigCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *RobotConfigCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotConfigCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotConfigCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotConfigCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotConfigCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotConfigCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotConfigCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RobotConfigCmdMultiError(errors)
	}

	return nil
}

// RobotConfigCmdMultiError is an error wrapping multiple validation errors
// returned by RobotConfigCmd.ValidateAll() if the designated constraints
// aren't met.
type RobotConfigCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RobotConfigCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RobotConfigCmdMultiError) AllErrors() []error { return m }

// RobotConfigCmdValidationError is the validation error returned by
// RobotConfigCmd.Validate if the designated constraints aren't met.
type RobotConfigCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RobotConfigCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RobotConfigCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RobotConfigCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RobotConfigCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RobotConfigCmdValidationError) ErrorName() string { return "RobotConfigCmdValidationError" }

// Error satisfies the builtin error interface
func (e RobotConfigCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRobotConfigCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RobotConfigCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RobotConfigCmdValidationError{}

// Validate checks the field values on RobotCommandCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RobotCommandCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RobotCommandCmd with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RobotCommandCmdMultiError, or nil if none found.
func (m *RobotCommandCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *RobotCommandCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotCommandCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotCommandCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotCommandCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotCommandCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotCommandCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotCommandCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RobotCommandCmdMultiError(errors)
	}

	return nil
}

// RobotCommandCmdMultiError is an error wrapping multiple validation errors
// returned by RobotCommandCmd.ValidateAll() if the designated constraints
// aren't met.
type RobotCommandCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RobotCommandCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RobotCommandCmdMultiError) AllErrors() []error { return m }

// RobotCommandCmdValidationError is the validation error returned by
// RobotCommandCmd.Validate if the designated constraints aren't met.
type RobotCommandCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RobotCommandCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RobotCommandCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RobotCommandCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RobotCommandCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RobotCommandCmdValidationError) ErrorName() string { return "RobotCommandCmdValidationError" }

// Error satisfies the builtin error interface
func (e RobotCommandCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRobotCommandCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RobotCommandCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RobotCommandCmdValidationError{}

// Validate checks the field values on RobotResultCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RobotResultCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RobotResultCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RobotResultCmdMultiError,
// or nil if none found.
func (m *RobotResultCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *RobotResultCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotResultCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotResultCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotResultCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RobotResultCmdMultiError(errors)
	}

	return nil
}

// RobotResultCmdMultiError is an error wrapping multiple validation errors
// returned by RobotResultCmd.ValidateAll() if the designated constraints
// aren't met.
type RobotResultCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RobotResultCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RobotResultCmdMultiError) AllErrors() []error { return m }

// RobotResultCmdValidationError is the validation error returned by
// RobotResultCmd.Validate if the designated constraints aren't met.
type RobotResultCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RobotResultCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RobotResultCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RobotResultCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RobotResultCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RobotResultCmdValidationError) ErrorName() string { return "RobotResultCmdValidationError" }

// Error satisfies the builtin error interface
func (e RobotResultCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRobotResultCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RobotResultCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RobotResultCmdValidationError{}

// Validate checks the field values on ServerSyncCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ServerSyncCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerSyncCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ServerSyncCmdMultiError, or
// nil if none found.
func (m *ServerSyncCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerSyncCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerSyncCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerSyncCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerSyncCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerSyncCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerSyncCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerSyncCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServerSyncCmdMultiError(errors)
	}

	return nil
}

// ServerSyncCmdMultiError is an error wrapping multiple validation errors
// returned by ServerSyncCmd.ValidateAll() if the designated constraints
// aren't met.
type ServerSyncCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerSyncCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerSyncCmdMultiError) AllErrors() []error { return m }

// ServerSyncCmdValidationError is the validation error returned by
// ServerSyncCmd.Validate if the designated constraints aren't met.
type ServerSyncCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerSyncCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerSyncCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerSyncCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerSyncCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerSyncCmdValidationError) ErrorName() string { return "ServerSyncCmdValidationError" }

// Error satisfies the builtin error interface
func (e ServerSyncCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerSyncCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerSyncCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerSyncCmdValidationError{}

// Validate checks the field values on ServerStatusCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ServerStatusCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ServerStatusCmd with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ServerStatusCmdMultiError, or nil if none found.
func (m *ServerStatusCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *ServerStatusCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerStatusCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerStatusCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerStatusCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ServerStatusCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ServerStatusCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ServerStatusCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ServerStatusCmdMultiError(errors)
	}

	return nil
}

// ServerStatusCmdMultiError is an error wrapping multiple validation errors
// returned by ServerStatusCmd.ValidateAll() if the designated constraints
// aren't met.
type ServerStatusCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServerStatusCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServerStatusCmdMultiError) AllErrors() []error { return m }

// ServerStatusCmdValidationError is the validation error returned by
// ServerStatusCmd.Validate if the designated constraints aren't met.
type ServerStatusCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServerStatusCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServerStatusCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServerStatusCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServerStatusCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServerStatusCmdValidationError) ErrorName() string { return "ServerStatusCmdValidationError" }

// Error satisfies the builtin error interface
func (e ServerStatusCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sServerStatusCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServerStatusCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServerStatusCmdValidationError{}

// Validate checks the field values on AlertSendCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AlertSendCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AlertSendCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AlertSendCmdMultiError, or
// nil if none found.
func (m *AlertSendCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *AlertSendCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlertSendCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlertSendCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlertSendCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlertSendCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlertSendCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlertSendCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AlertSendCmdMultiError(errors)
	}

	return nil
}

// AlertSendCmdMultiError is an error wrapping multiple validation errors
// returned by AlertSendCmd.ValidateAll() if the designated constraints aren't met.
type AlertSendCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlertSendCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlertSendCmdMultiError) AllErrors() []error { return m }

// AlertSendCmdValidationError is the validation error returned by
// AlertSendCmd.Validate if the designated constraints aren't met.
type AlertSendCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlertSendCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlertSendCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlertSendCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlertSendCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlertSendCmdValidationError) ErrorName() string { return "AlertSendCmdValidationError" }

// Error satisfies the builtin error interface
func (e AlertSendCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlertSendCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlertSendCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlertSendCmdValidationError{}

// Validate checks the field values on AlertAckCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AlertAckCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AlertAckCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AlertAckCmdMultiError, or
// nil if none found.
func (m *AlertAckCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *AlertAckCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlertAckCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlertAckCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlertAckCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AlertAckCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AlertAckCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AlertAckCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AlertAckCmdMultiError(errors)
	}

	return nil
}

// AlertAckCmdMultiError is an error wrapping multiple validation errors
// returned by AlertAckCmd.ValidateAll() if the designated constraints aren't met.
type AlertAckCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlertAckCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlertAckCmdMultiError) AllErrors() []error { return m }

// AlertAckCmdValidationError is the validation error returned by
// AlertAckCmd.Validate if the designated constraints aren't met.
type AlertAckCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlertAckCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlertAckCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlertAckCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlertAckCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlertAckCmdValidationError) ErrorName() string { return "AlertAckCmdValidationError" }

// Error satisfies the builtin error interface
func (e AlertAckCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlertAckCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlertAckCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlertAckCmdValidationError{}

// Validate checks the field values on UserKickCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *UserKickCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserKickCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in UserKickCmdMultiError, or
// nil if none found.
func (m *UserKickCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *UserKickCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserKickCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserKickCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserKickCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserKickCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserKickCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserKickCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserKickCmdMultiError(errors)
	}

	return nil
}

// UserKickCmdMultiError is an error wrapping multiple validation errors
// returned by UserKickCmd.ValidateAll() if the designated constraints aren't met.
type UserKickCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserKickCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserKickCmdMultiError) AllErrors() []error { return m }

// UserKickCmdValidationError is the validation error returned by
// UserKickCmd.Validate if the designated constraints aren't met.
type UserKickCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserKickCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserKickCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserKickCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserKickCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserKickCmdValidationError) ErrorName() string { return "UserKickCmdValidationError" }

// Error satisfies the builtin error interface
func (e UserKickCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserKickCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserKickCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserKickCmdValidationError{}

// Validate checks the field values on UserBroadcastCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UserBroadcastCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UserBroadcastCmd with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UserBroadcastCmdMultiError, or nil if none found.
func (m *UserBroadcastCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *UserBroadcastCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserBroadcastCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserBroadcastCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserBroadcastCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UserBroadcastCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UserBroadcastCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UserBroadcastCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UserBroadcastCmdMultiError(errors)
	}

	return nil
}

// UserBroadcastCmdMultiError is an error wrapping multiple validation errors
// returned by UserBroadcastCmd.ValidateAll() if the designated constraints
// aren't met.
type UserBroadcastCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UserBroadcastCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UserBroadcastCmdMultiError) AllErrors() []error { return m }

// UserBroadcastCmdValidationError is the validation error returned by
// UserBroadcastCmd.Validate if the designated constraints aren't met.
type UserBroadcastCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserBroadcastCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserBroadcastCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserBroadcastCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserBroadcastCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserBroadcastCmdValidationError) ErrorName() string { return "UserBroadcastCmdValidationError" }

// Error satisfies the builtin error interface
func (e UserBroadcastCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserBroadcastCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserBroadcastCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserBroadcastCmdValidationError{}

// Validate checks the field values on RobotSyncCmd with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RobotSyncCmd) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RobotSyncCmd with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RobotSyncCmdMultiError, or
// nil if none found.
func (m *RobotSyncCmd) ValidateAll() error {
	return m.validate(true)
}

func (m *RobotSyncCmd) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Request != nil {

		if all {
			switch v := interface{}(m.GetRequest()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotSyncCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotSyncCmdValidationError{
						field:  "Request",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRequest()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotSyncCmdValidationError{
					field:  "Request",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Response != nil {

		if all {
			switch v := interface{}(m.GetResponse()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RobotSyncCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RobotSyncCmdValidationError{
						field:  "Response",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResponse()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RobotSyncCmdValidationError{
					field:  "Response",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RobotSyncCmdMultiError(errors)
	}

	return nil
}

// RobotSyncCmdMultiError is an error wrapping multiple validation errors
// returned by RobotSyncCmd.ValidateAll() if the designated constraints aren't met.
type RobotSyncCmdMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RobotSyncCmdMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RobotSyncCmdMultiError) AllErrors() []error { return m }

// RobotSyncCmdValidationError is the validation error returned by
// RobotSyncCmd.Validate if the designated constraints aren't met.
type RobotSyncCmdValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RobotSyncCmdValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RobotSyncCmdValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RobotSyncCmdValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RobotSyncCmdValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RobotSyncCmdValidationError) ErrorName() string { return "RobotSyncCmdValidationError" }

// Error satisfies the builtin error interface
func (e RobotSyncCmdValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRobotSyncCmd.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RobotSyncCmdValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RobotSyncCmdValidationError{}
